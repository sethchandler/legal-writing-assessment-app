<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Legal Writing Assessment Tool</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- Mammoth for DOCX -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <!-- JSZip for creating zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const ASSESSMENT_TEMPLATE_INSTRUCTIONS = `Respond using the exact structure below. Include every heading even if a section is brief.

### Assessment Summary
- Overall Score: <number>/100
- Snapshot: <one-sentence highlight of performance>

### Rubric Feedback
- Statutory & Traditional Amenability (score/10): <feedback>
- General Jurisdiction Analysis (score/10): <feedback>
- Specific Jurisdiction â€“ Purposeful Availment (score/30): <feedback>
- Specific Jurisdiction â€“ Arise Out Of / Relate To (score/20): <feedback>
- Specific Jurisdiction â€“ Reasonableness (score/30): <feedback>

### Writing & Organization
- Strengths: <comma-separated or bulleted strengths targeting writing choices>
- Improvement Opportunities: <comma-separated or bulleted improvements>

### Next Steps
1. <first prioritized action item>
2. <second prioritized action item>`;

        const MAX_COMPLETION_TOKEN_LIMITS = {
            anthropic: 8000,
            openai: 16000,
            google: 8192,
            openrouter: {
                anthropic: 8000,
                openai: 16000,
                google: 8192,
                default: 16000
            }
        };

        // Initialize PDF.js worker
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }

        function App() {
            const [mode, setMode] = useState('single'); // 'single' or 'batch'
            const [inputMode, setInputMode] = useState('form'); // 'form' or 'json'
            const [step, setStep] = useState(1);
            const [formData, setFormData] = useState({
                question: '',
                studentAnswer: '',
                modelAnswer: '',
                rubric: ''
            });
            const [jsonInput, setJsonInput] = useState('');
            const [provider, setProvider] = useState('anthropic');
            const [apiKey, setApiKey] = useState('');
            const [model, setModel] = useState('claude-sonnet-4-5-20250929');
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');
            const [statusMessage, setStatusMessage] = useState('');
            const [elapsedTime, setElapsedTime] = useState(0);
            const [jsonData, setJsonData] = useState(null);
            const [assessment, setAssessment] = useState(null);
            const timerRef = useRef(null);
            
            // Batch mode states
            const [batchFiles, setBatchFiles] = useState([]);
            const [processingProgress, setProcessingProgress] = useState(0);
            const [currentlyProcessing, setCurrentlyProcessing] = useState('');
            const [processedCount, setProcessedCount] = useState(0);
            const [totalCount, setTotalCount] = useState(0);
            const [batchResults, setBatchResults] = useState([]);
            const fileInputRef = useRef(null);
            const jsonFileInputRef = useRef(null);
            
            // Output control states
            const [outputControls, setOutputControls] = useState({
                includeQuestion: true,
                includeStudentAnswer: true,
                includeModelAnswer: false,
                includeRubric: false,
                includeAssessment: false,
                includeChallenge: false,
                includeArbitration: false,
                includeFinalAssessment: true
            });

            // Caching control state
            const [cachingEnabled, setCachingEnabled] = useState(true);

            // Error handling states
            const [errorDiagnosisModel, setErrorDiagnosisModel] = useState(null);
            const [useCustomErrorModel, setUseCustomErrorModel] = useState(false);

            // Error mapping dictionary for common errors
            const ERROR_MESSAGE_MAP = {
                // Authentication errors
                'invalid api key': 'Invalid API key for the selected provider. Please check your API key and try again.',
                'unauthorized': 'Unauthorized access. Please verify your API key is correct and has the necessary permissions.',
                'invalid_api_key': 'Invalid API key. Please check your API key and try again.',
                '401': 'Authentication failed. Please verify your API key is correct.',
                'unauthorized_client': 'Your API key is not authorized. Please check your credentials.',

                // Rate limiting
                'rate_limit': 'Rate limit exceeded. Please wait a moment before trying again.',
                'too_many_requests': 'Too many requests. Please wait before processing more files.',
                '429': 'Rate limit exceeded. Please wait a few moments and try again.',
                'quota_exceeded': 'API quota exceeded. Please check your plan or wait for quota to reset.',

                // Model errors
                'model not found': 'The selected model is not available. Please choose a different model.',
                'invalid_model': 'The selected model is not available on this provider.',
                'model_not_found': 'Model not found. Please select a different model.',
                'does not exist': 'The selected model does not exist on this provider.',

                // Request errors
                'invalid request': 'Invalid request format. Please check your input and try again.',
                'bad request': 'Bad request. Please check your input and try again.',
                '400': 'Invalid request. Please check your input and try again.',
                'invalid_parameter': 'Invalid parameter in request. Please check your settings.',

                // Network errors
                'network error': 'Network connection error. Please check your internet connection and try again.',
                'enotfound': 'Could not reach the API server. Please check your internet connection.',
                'timeout': 'Request timed out. Please try again.',
                'econnrefused': 'Connection refused. The API server may be temporarily unavailable.',
                'fetch failed': 'Failed to connect to the API. Please check your internet connection.',

                // File parsing errors
                'failed to parse file': 'Could not read the file. The file may be corrupted or in an unsupported format.',
                'invalid file': 'Invalid file format. Please ensure the file is in a supported format (PDF, DOCX, TXT, etc).',
                'unsupported file': 'Unsupported file format. Please use PDF, Word, or text files.',
                'parse error': 'Failed to parse file content. The file may be corrupted.',

                // Missing data errors
                'missing question': 'Question is required. Please provide a legal question.',
                'missing student answer': 'Student answer is required. Please provide the student\'s response.',
                'missing model answer': 'Model answer is required. Please provide the reference answer.',
                'missing rubric': 'Rubric is required. Please provide evaluation criteria.',
                'missing required': 'Missing required field. Please fill in all required fields.',

                // Context/token errors
                'context length': 'Content too long. Please reduce the length of your input text.',
                'maximum tokens': 'Input exceeds maximum length. Please shorten your text.',
                'context_length_exceeded': 'Input too long for this model. Please use shorter content.',
                'token limit': 'Token limit exceeded. Please reduce the amount of text.',

                // Server errors
                'server error': 'Server error occurred. Please try again later.',
                '500': 'Internal server error. Please try again later.',
                '503': 'Service temporarily unavailable. Please try again later.',
                'service unavailable': 'The API service is temporarily unavailable. Please try again later.'
            };

            // Translate error to user-friendly message
            const translateError = async (error, shouldUseLLM = true) => {
                const errorStr = (error?.message || String(error)).toLowerCase();

                console.log('Raw error:', errorStr);

                // Check against error mapping dictionary
                for (const [key, message] of Object.entries(ERROR_MESSAGE_MAP)) {
                    if (errorStr.includes(key)) {
                        console.log('Found error mapping for:', key);
                        return {
                            friendly: message,
                            raw: error?.message || String(error),
                            translated: true,
                            method: 'dictionary'
                        };
                    }
                }

                // If not in dictionary and LLM is available, try LLM translation
                if (shouldUseLLM && apiKey) {
                    try {
                        console.log('Attempting LLM error translation');
                        const translated = await translateErrorWithLLM(error);
                        return translated;
                    } catch (llmError) {
                        console.log('LLM translation failed, using raw error:', llmError);
                    }
                }

                // Fallback to raw error
                return {
                    friendly: 'An error occurred during processing. See details below.',
                    raw: error?.message || String(error),
                    translated: false,
                    method: 'fallback'
                };
            };

            // Use LLM to translate error messages
            const translateErrorWithLLM = async (error) => {
                const errorMessage = error?.message || String(error);
                const translationPrompt = `You are a helpful assistant explaining technical errors to non-technical users (law professors and students).
Translate this technical error message into plain, clear English that explains what went wrong and suggests a solution.
Be concise (1-2 sentences max).

Technical error: "${errorMessage}"

Plain English explanation:`;

                try {
                    // Determine which model to use
                    const selectedModel = useCustomErrorModel && errorDiagnosisModel ? errorDiagnosisModel : model;
                    const selectedProvider = useCustomErrorModel && errorDiagnosisModel ? provider : provider;

                    console.log('Translating error with model:', selectedModel, 'provider:', selectedProvider);

                    let response;

                    if (selectedProvider === 'anthropic') {
                        const res = await fetch('https://api.anthropic.com/v1/messages/create', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-api-key': apiKey,
                                'anthropic-version': '2023-06-01'
                            },
                            body: JSON.stringify({
                                model: selectedModel,
                                max_tokens: 200,
                                messages: [
                                    { role: 'user', content: translationPrompt }
                                ]
                            })
                        });
                        const data = await res.json();
                        if (data.error) throw new Error(data.error.message);
                        response = data.content[0].text;
                    } else if (selectedProvider === 'openai') {
                        const res = await fetch('https://api.openai.com/v1/chat/completions', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({
                                model: selectedModel,
                                messages: [
                                    { role: 'system', content: 'You are a helpful assistant.' },
                                    { role: 'user', content: translationPrompt }
                                ],
                                max_tokens: 200
                            })
                        });
                        const data = await res.json();
                        if (data.error) throw new Error(data.error.message);
                        response = data.choices[0].message.content;
                    } else if (selectedProvider === 'google') {
                        const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${apiKey}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: translationPrompt }] }],
                                generationConfig: { maxOutputTokens: 200 }
                            })
                        });
                        const data = await res.json();
                        if (data.error) throw new Error(data.error.message);
                        response = data.candidates[0].content.parts[0].text;
                    } else if (selectedProvider === 'openrouter') {
                        const res = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({
                                model: selectedModel,
                                messages: [
                                    { role: 'user', content: translationPrompt }
                                ],
                                max_tokens: 200
                            })
                        });
                        const data = await res.json();
                        if (data.error) throw new Error(data.error.message);
                        response = data.choices[0].message.content;
                    }

                    return {
                        friendly: response,
                        raw: errorMessage,
                        translated: true,
                        method: 'llm'
                    };
                } catch (llmErr) {
                    console.log('LLM translation failed:', llmErr);
                    throw llmErr;
                }
            };

            // Load API key from localStorage
            useEffect(() => {
                const savedKey = localStorage.getItem(`apiKey_${provider}`);
                if (savedKey) setApiKey(savedKey);
            }, [provider]);

            // Timer for showing elapsed time during processing
            useEffect(() => {
                if (loading) {
                    setElapsedTime(0);
                    timerRef.current = setInterval(() => {
                        setElapsedTime(prev => prev + 1);
                    }, 1000);
                } else {
                    if (timerRef.current) {
                        clearInterval(timerRef.current);
                    }
                }
                return () => {
                    if (timerRef.current) {
                        clearInterval(timerRef.current);
                    }
                };
            }, [loading]);

            // Save API key to localStorage
            const handleApiKeyChange = (value) => {
                setApiKey(value);
                if (value) {
                    localStorage.setItem(`apiKey_${provider}`, value);
                }
            };

            const handleInputChange = (field, value) => {
                setFormData(prev => ({ ...prev, [field]: value }));
            };

            const handleOutputControlChange = (field, checked) => {
                setOutputControls(prev => ({ ...prev, [field]: checked }));
            };

            // Caching support detection
            const supportsCaching = (provider, model, enabled) => {
                if (!enabled) {
                    return { supported: false, method: null };
                }

                if (provider === 'anthropic') {
                    return { supported: true, method: 'anthropic' };
                }

                if (provider === 'openai') {
                    return { supported: true, method: 'openai' };
                }

                if (provider === 'google') {
                    if (model.includes('gemini-2.5-flash') || model.includes('gemini-2.5-pro')) {
                        return { supported: true, method: 'implicit' };
                    }
                    return { supported: false, method: null };
                }

                if (provider === 'openrouter') {
                    if (model.startsWith('anthropic/')) {
                        return { supported: true, method: 'anthropic' };
                    }
                    if (model.startsWith('openai/')) {
                        return { supported: true, method: 'openai' };
                    }
                    if (model.includes('gemini-2.5')) {
                        return { supported: true, method: 'implicit' };
                    }
                    return { supported: false, method: null };
                }

                return { supported: false, method: null };
            };

            // File parsing functions
            const parseTextFile = async (file) => {
                return await file.text();
            };

            const parseMarkdownFile = async (file) => {
                return await file.text();
            };

            const parsePDFFile = async (file) => {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    let fullText = '';
                    
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        const pageText = textContent.items.map(item => item.str).join(' ');
                        fullText += pageText + '\n';
                    }
                    
                    return fullText;
                } catch (err) {
                    throw new Error(`PDF parsing failed: ${err.message}`);
                }
            };

            const parseDOCXFile = async (file) => {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const result = await mammoth.extractRawText({ arrayBuffer });
                    return result.value;
                } catch (err) {
                    throw new Error(`DOCX parsing failed: ${err.message}`);
                }
            };

            const parseFile = async (file) => {
                const extension = file.name.split('.').pop().toLowerCase();
                
                switch (extension) {
                    case 'txt':
                        return await parseTextFile(file);
                    case 'md':
                    case 'markdown':
                        return await parseMarkdownFile(file);
                    case 'pdf':
                        return await parsePDFFile(file);
                    case 'docx':
                        return await parseDOCXFile(file);
                    default:
                        throw new Error(`Unsupported file type: .${extension}`);
                }
            };

            const handleFileUpload = async (field, file) => {
                try {
                    const text = await parseFile(file);
                    handleInputChange(field, text);
                } catch (err) {
                    setError(`Error reading ${file.name}: ${err.message}`);
                }
            };

            // Batch mode file handling
            const handleBatchFilesSelect = async (files) => {
                const fileArray = Array.from(files);
                const newFiles = fileArray.map(file => ({
                    file,
                    name: file.name,
                    size: file.size,
                    status: 'pending',
                    content: null,
                    result: null,
                    error: null
                }));
                
                setBatchFiles(prev => [...prev, ...newFiles]);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                const files = e.dataTransfer.files;
                handleBatchFilesSelect(files);
            };

            const handleDragOver = (e) => {
                e.preventDefault();
                e.stopPropagation();
            };

            const removeFile = (index) => {
                setBatchFiles(prev => prev.filter((_, i) => i !== index));
            };

            const getMissingFields = () => {
                const missing = [];
                if (!formData.question) missing.push('question');
                if (!formData.modelAnswer) missing.push('modelAnswer');
                if (!formData.rubric) missing.push('rubric');
                return missing;
            };

            const generateMissingFields = async (studentAnswer) => {
                const missing = getMissingFields();
                let currentData = { ...formData, studentAnswer };

                for (const field of missing) {
                    if (field === 'question') {
                        setStatusMessage('ðŸ¤– Generating question from student answer...');
                        const prompt = `Given this student answer for a legal writing assessment, generate an appropriate legal exam question that this answer would be responding to. The question should be in IRAC or CREAC format and involve a realistic legal scenario.

Student Answer:
${currentData.studentAnswer}

Generate ONLY the question text, no additional commentary.`;

                        const response = await callLLM(prompt);
                        currentData.question = response;
                        setStatusMessage('âœ“ Question generated');
                    }

                    if (field === 'modelAnswer') {
                        setStatusMessage('ðŸ¤– Generating model answer...');
                        const prompt = `Given this legal exam question and student answer, generate a model answer that demonstrates excellent legal analysis in IRAC or CREAC format.

Question:
${currentData.question}

Student Answer (for context):
${currentData.studentAnswer}

Generate ONLY the model answer text, no additional commentary.`;

                        const response = await callLLM(prompt);
                        currentData.modelAnswer = response;
                        setStatusMessage('âœ“ Model answer generated');
                    }

                    if (field === 'rubric') {
                        setStatusMessage('ðŸ¤– Generating grading rubric...');
                        const prompt = `Generate a grading rubric for this legal writing assessment question. The rubric should evaluate:
- Analytical Depth (50%)
- Rule Statement (20%)
- Issue Spotting (15%)
- Organization (15%)

Question:
${currentData.question}

Format the rubric with clear scoring criteria for each component.`;

                        const response = await callLLM(prompt);
                        currentData.rubric = response;
                        setStatusMessage('âœ“ Rubric generated');
                    }
                }

                setStatusMessage('âœ“ JSON structure created');
                return currentData;
            };

            const performSingleAssessment = async (data) => {
                setStatusMessage('ðŸ¤– Analyzing legal writing...');
                console.log('performSingleAssessment called with data:', { hasQuestion: !!data.question, hasStudentAnswer: !!data.studentAnswer, hasModelAnswer: !!data.modelAnswer, hasRubric: !!data.rubric });

                // Check if caching is supported
                const cachingInfo = supportsCaching(provider, model, cachingEnabled);
                console.log('Caching info:', cachingInfo);

                let result;
                if (cachingInfo.supported) {
                    // Split prompt into cacheable and non-cacheable parts
                    const cacheableContent = `You are an expert legal writing professor. Assess this student's legal analysis answer using the provided question, model answer, and rubric.

QUESTION:
${data.question}

MODEL ANSWER:
${data.modelAnswer}

RUBRIC:
${data.rubric}

RESPONSE TEMPLATE (MANDATORY):
${ASSESSMENT_TEMPLATE_INSTRUCTIONS}`;

                    const nonCacheableContent = `STUDENT ANSWER:
${data.studentAnswer}

Provide a comprehensive assessment that follows the response template and tailors commentary to this student's work.`;

                    const fullPrompt = cacheableContent + '\n\n' + nonCacheableContent;

                    const response = await callLLM(fullPrompt, {
                        enabled: cachingEnabled,
                        method: cachingInfo.method,
                        cacheableContent: cacheableContent,
                        nonCacheableContent: nonCacheableContent
                    });
                    result = response;
                } else {
                    // No caching support, use standard prompt
                    const assessmentPrompt = `You are an expert legal writing professor. Assess this student's legal analysis answer using the provided question, model answer, and rubric.

QUESTION:
${data.question}

STUDENT ANSWER:
${data.studentAnswer}

MODEL ANSWER:
${data.modelAnswer}

RUBRIC:
${data.rubric}

RESPONSE TEMPLATE (MANDATORY):
${ASSESSMENT_TEMPLATE_INSTRUCTIONS}

Fill in each section with specific, student-focused feedback and concrete, actionable advice.`;

                    const response = await callLLM(assessmentPrompt);
                    result = response;
                }

                setStatusMessage('âœ“ Assessment complete');
                return result;
            };

            const performChallenge = async (data, assessment) => {
                console.log('performChallenge called with:', { hasData: !!data, hasAssessment: !!assessment });
                setStatusMessage('ðŸŽ¯ Student advocate reviewing assessment...');

                const challengePrompt = `You are a student advocate reviewing an assessment for fairness. Your role is to identify any legitimate ways the student's work may have been under-credited.

QUESTION:
${data.question}

STUDENT ANSWER:
${data.studentAnswer}

MODEL ANSWER:
${data.modelAnswer}

RUBRIC:
${data.rubric}

ORIGINAL ASSESSMENT:
${assessment}

Your task:
1. Review the assessment carefully for fairness
2. Identify where the student demonstrated understanding that may not have been fully credited
3. Make plausible, reasonable arguments for the student
4. Focus on whether the assessment fairly rewarded what the student actually did

DO NOT:
- Challenge the correctness of the rubric or model answer
- Challenge whether the test is fair
- Make ridiculous or far-fetched arguments
- Simply advocate for a higher grade without justification

Provide a structured response:
### Areas of Potential Under-Recognition
[List specific points where student work may deserve more credit]

### Supporting Arguments
[For each area, explain why additional credit may be warranted]

### Conclusion
[Brief summary of the strongest arguments for reconsideration]`;

                const challenge = await callLLM(challengePrompt);
                console.log('performChallenge completed, challenge length:', challenge?.length);
                setStatusMessage('âœ“ Challenge completed');
                return challenge;
            };

            const performArbitration = async (data, assessment, challenge) => {
                console.log('performArbitration called with:', { hasData: !!data, hasAssessment: !!assessment, hasChallenge: !!challenge });
                setStatusMessage('âš–ï¸ Arbitrator reviewing challenge...');

                const arbitrationPrompt = `You are a fair arbitrator reviewing a challenge to an assessment. Your role is to determine if the challenge has merit and whether the assessment should be revised.

Context: You are operating in a zero-sum grading system where every point given to one student affects others. You must be fair to the student but not lenient. Legitimate challenges should be respected, but grade inflation must be avoided.

QUESTION:
${data.question}

STUDENT ANSWER:
${data.studentAnswer}

MODEL ANSWER:
${data.modelAnswer}

RUBRIC:
${data.rubric}

ORIGINAL ASSESSMENT:
${assessment}

STUDENT ADVOCATE'S CHALLENGE:
${challenge}

Your task:
1. Evaluate each argument in the challenge for validity
2. Determine if the original assessment missed legitimate demonstrations of competence
3. Decide what revisions, if any, are warranted
4. Revise the assessment only where truly justified

Provide a structured response:
### Challenge Review
[Evaluate each major argument - valid, partially valid, or not valid]

### Arbitrator's Decision
[For each valid or partially valid point, explain what revision is warranted and why]

### Revised Assessment
[Provide the complete revised assessment incorporating only legitimate adjustments. Use the same format as the original assessment template, updating scores and feedback as appropriate.]`;

                const arbitration = await callLLM(arbitrationPrompt);
                console.log('performArbitration completed, arbitration length:', arbitration?.length);
                setStatusMessage('âœ“ Arbitration completed');
                return arbitration;
            };

            // Single mode processing
            const processSingleMode = async () => {
                if (!apiKey) {
                    setError('Please provide an API key first');
                    return;
                }

                setLoading(true);
                setError('');
                setStatusMessage('Starting...');

                try {
                    let json;
                    let allFieldsProvided = false;

                    if (inputMode === 'json') {
                        // Parse uploaded JSON
                        setStatusMessage('ðŸ“„ Parsing JSON input...');
                        json = JSON.parse(jsonInput);
                        setStatusMessage('âœ“ JSON parsed successfully');

                        // Check if all required fields are provided
                        allFieldsProvided = json.question && json.studentAnswer && json.modelAnswer && json.rubric;
                    } else {
                        // Check if all form fields are provided
                        allFieldsProvided = formData.question && formData.studentAnswer && formData.modelAnswer && formData.rubric;

                        if (allFieldsProvided) {
                            // All fields provided, use them directly
                            json = {
                                question: formData.question,
                                studentAnswer: formData.studentAnswer,
                                modelAnswer: formData.modelAnswer,
                                rubric: formData.rubric,
                                metadata: {
                                    generatedAt: new Date().toISOString(),
                                    generatedFields: []
                                }
                            };
                        } else {
                            // Generate missing fields
                            setStatusMessage('ðŸ“ Creating assessment data...');
                            const completeData = await generateMissingFields(formData.studentAnswer);

                            json = {
                                question: completeData.question,
                                studentAnswer: completeData.studentAnswer,
                                modelAnswer: completeData.modelAnswer,
                                rubric: completeData.rubric,
                                metadata: {
                                    generatedAt: new Date().toISOString(),
                                    generatedFields: getMissingFields()
                                }
                            };
                        }
                    }

                    setJsonData(json);

                    // Smart detection: if all fields provided, proceed directly to assessment
                    if (allFieldsProvided) {
                        console.log('processSingleMode: allFieldsProvided=true, proceeding to 3-step workflow');
                        setStatusMessage('âœ“ All fields provided - proceeding to assessment...');

                        // Step 1: Initial assessment
                        console.log('processSingleMode: calling performSingleAssessment');
                        const initialAssessment = await performSingleAssessment(json);
                        console.log('processSingleMode: initialAssessment completed, length:', initialAssessment?.length);

                        // Step 2: Challenge (student advocate)
                        console.log('processSingleMode: calling performChallenge');
                        const challenge = await performChallenge(json, initialAssessment);
                        console.log('processSingleMode: challenge completed, length:', challenge?.length);

                        // Step 3: Arbitration
                        console.log('processSingleMode: calling performArbitration');
                        const arbitration = await performArbitration(json, initialAssessment, challenge);
                        console.log('processSingleMode: arbitration completed, length:', arbitration?.length);

                        // Store all results
                        const completeAssessment = {
                            original: initialAssessment,
                            challenge: challenge,
                            arbitration: arbitration
                        };
                        console.log('processSingleMode: completeAssessment created:', {
                            hasOriginal: !!completeAssessment.original,
                            hasChallenge: !!completeAssessment.challenge,
                            hasArbitration: !!completeAssessment.arbitration
                        });

                        setAssessment(completeAssessment);
                        console.log('processSingleMode: setAssessment called');
                        setStep(3);
                        setStatusMessage('');
                    } else {
                        // Missing fields were generated, show step 2 for review
                        setStep(2);
                        setStatusMessage('');
                    }
                } catch (err) {
                    setError(err.message);
                    setStatusMessage('');
                } finally {
                    setLoading(false);
                }
            };

            const performSingleAssessmentStep = async () => {
                if (!jsonData) return;

                console.log('performSingleAssessmentStep called, jsonData exists:', !!jsonData);
                setLoading(true);
                setError('');

                try {
                    // Step 1: Initial assessment
                    console.log('performSingleAssessmentStep: calling performSingleAssessment');
                    const initialAssessment = await performSingleAssessment(jsonData);
                    console.log('performSingleAssessmentStep: initialAssessment completed, length:', initialAssessment?.length);

                    // Step 2: Challenge (student advocate)
                    console.log('performSingleAssessmentStep: calling performChallenge');
                    const challenge = await performChallenge(jsonData, initialAssessment);
                    console.log('performSingleAssessmentStep: challenge completed, length:', challenge?.length);

                    // Step 3: Arbitration
                    console.log('performSingleAssessmentStep: calling performArbitration');
                    const arbitration = await performArbitration(jsonData, initialAssessment, challenge);
                    console.log('performSingleAssessmentStep: arbitration completed, length:', arbitration?.length);

                    // Store all results
                    const completeAssessment = {
                        original: initialAssessment,
                        challenge: challenge,
                        arbitration: arbitration
                    };
                    console.log('performSingleAssessmentStep: completeAssessment created:', {
                        hasOriginal: !!completeAssessment.original,
                        hasChallenge: !!completeAssessment.challenge,
                        hasArbitration: !!completeAssessment.arbitration
                    });

                    setAssessment(completeAssessment);
                    console.log('performSingleAssessmentStep: setAssessment called');
                    setStep(3);
                    setStatusMessage('');
                } catch (err) {
                    setError(err.message);
                    setStatusMessage('');
                } finally {
                    setLoading(false);
                }
            };

            const downloadJSON = (data, filename) => {
                console.log('downloadJSON called with:', {
                    hasOriginalAssessment: !!data.originalAssessment,
                    hasChallenge: !!data.challenge,
                    hasArbitration: !!data.arbitration,
                    outputControls: outputControls
                });
                const filteredData = {};
                if (outputControls.includeQuestion && data.question) filteredData.question = data.question;
                if (outputControls.includeStudentAnswer && data.studentAnswer) filteredData.studentAnswer = data.studentAnswer;
                if (outputControls.includeModelAnswer && data.modelAnswer) filteredData.modelAnswer = data.modelAnswer;
                if (outputControls.includeRubric && data.rubric) filteredData.rubric = data.rubric;

                // Handle new challenge workflow format
                if (data.originalAssessment || data.challenge || data.arbitration) {
                    // Has challenge workflow data
                    if (outputControls.includeAssessment && data.originalAssessment) {
                        filteredData.originalAssessment = data.originalAssessment;
                    }
                    if (outputControls.includeChallenge && data.challenge) {
                        filteredData.challenge = data.challenge;
                    }
                    if (outputControls.includeArbitration && data.arbitration) {
                        filteredData.arbitrationReview = data.arbitration;
                    }
                    if (outputControls.includeFinalAssessment && data.arbitration) {
                        filteredData.finalAssessment = data.arbitration;
                    }
                } else if (data.assessment && outputControls.includeAssessment) {
                    // Legacy format support
                    filteredData.assessment = data.assessment;
                }

                if (data.metadata) filteredData.metadata = data.metadata;

                const blob = new Blob([JSON.stringify(filteredData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            };

            const downloadText = (assessmentData, filename) => {
                console.log('downloadText called with:', {
                    assessmentType: typeof assessmentData,
                    hasOriginal: assessmentData?.original,
                    hasChallenge: assessmentData?.challenge,
                    hasArbitration: assessmentData?.arbitration,
                    outputControls: outputControls
                });
                let content = '';

                if (outputControls.includeQuestion && jsonData?.question) {
                    content += `QUESTION:\n${jsonData.question}\n\n`;
                }
                if (outputControls.includeStudentAnswer && jsonData?.studentAnswer) {
                    content += `STUDENT ANSWER:\n${jsonData.studentAnswer}\n\n`;
                }
                if (outputControls.includeModelAnswer && jsonData?.modelAnswer) {
                    content += `MODEL ANSWER:\n${jsonData.modelAnswer}\n\n`;
                }
                if (outputControls.includeRubric && jsonData?.rubric) {
                    content += `RUBRIC:\n${jsonData.rubric}\n\n`;
                }

                // Handle new challenge workflow format
                if (typeof assessmentData === 'object' && assessmentData.original) {
                    console.log('downloadText: detected challenge workflow format');
                    // New format with challenge workflow
                    if (outputControls.includeAssessment && assessmentData.original) {
                        console.log('downloadText: adding original assessment');
                        content += `ORIGINAL ASSESSMENT:\n${assessmentData.original}\n\n`;
                    }
                    if (outputControls.includeChallenge && assessmentData.challenge) {
                        console.log('downloadText: adding challenge');
                        content += `STUDENT ADVOCATE'S CHALLENGE:\n${assessmentData.challenge}\n\n`;
                    }
                    if (outputControls.includeArbitration && assessmentData.arbitration) {
                        console.log('downloadText: adding arbitration review');
                        content += `ARBITRATION REVIEW:\n${assessmentData.arbitration}\n\n`;
                    }
                    if (outputControls.includeFinalAssessment && assessmentData.arbitration) {
                        console.log('downloadText: adding final assessment');
                        content += `FINAL ASSESSMENT:\n${assessmentData.arbitration}\n\n`;
                    }
                } else if (typeof assessmentData === 'string') {
                    console.log('downloadText: detected legacy string format');
                    // Legacy format - single assessment string
                    if (outputControls.includeAssessment && assessmentData) {
                        content += `ASSESSMENT:\n${assessmentData}\n\n`;
                    }
                }
                console.log('downloadText: final content length:', content.length);

                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            };

            const handleJsonFileUpload = async (file) => {
                try {
                    const text = await file.text();
                    setJsonInput(text);
                    // Validate it's valid JSON
                    JSON.parse(text);
                    setError('');
                } catch (err) {
                    setError('Invalid JSON file: ' + err.message);
                }
            };

            // Batch mode processing
            const processBatchMode = async () => {
                if (!apiKey) {
                    setError('Please provide an API key first');
                    return;
                }

                if (batchFiles.length === 0) {
                    setError('Please upload at least one student answer file');
                    return;
                }

                setLoading(true);
                setError('');
                setProcessingProgress(0);
                setProcessedCount(0);
                setTotalCount(batchFiles.length);
                setBatchResults([]);

                try {
                    const results = [];
                    
                    for (let i = 0; i < batchFiles.length; i++) {
                        const fileInfo = batchFiles[i];
                        setCurrentlyProcessing(fileInfo.name);
                        setProcessedCount(i);
                        setStatusMessage(`Processing ${i + 1} of ${batchFiles.length}: ${fileInfo.name}`);
                        
                        // Update file status
                        setBatchFiles(prev => prev.map((f, idx) => 
                            idx === i ? { ...f, status: 'processing' } : f
                        ));

                        try {
                            // Parse file
                            let studentAnswer;
                            try {
                                studentAnswer = await parseFile(fileInfo.file);
                            } catch (parseErr) {
                                throw new Error(`Failed to parse file: ${parseErr.message}`);
                            }

                            // Generate missing fields
                            let completeData;
                            try {
                                completeData = await generateMissingFields(studentAnswer);
                            } catch (genErr) {
                                throw new Error(`Failed to generate assessment fields: ${genErr.message}`);
                            }

                            // Perform complete 3-step assessment workflow
                            let assessment;
                            try {
                                console.log(`Batch: Starting 3-step workflow for ${fileInfo.name}`);

                                // Step 1: Initial assessment
                                const initialAssessment = await performSingleAssessment(completeData);
                                console.log(`Batch: Initial assessment complete for ${fileInfo.name}`);

                                // Step 2: Challenge (student advocate)
                                const challenge = await performChallenge(completeData, initialAssessment);
                                console.log(`Batch: Challenge complete for ${fileInfo.name}`);

                                // Step 3: Arbitration
                                const arbitration = await performArbitration(completeData, initialAssessment, challenge);
                                console.log(`Batch: Arbitration complete for ${fileInfo.name}`);

                                // Store all results in proper format
                                assessment = {
                                    original: initialAssessment,
                                    challenge: challenge,
                                    arbitration: arbitration
                                };
                                console.log(`Batch: Complete assessment created for ${fileInfo.name}`);
                            } catch (assessErr) {
                                throw new Error(`Failed to perform assessment: ${assessErr.message}`);
                            }

                            results.push({
                                fileName: fileInfo.name,
                                assessment,
                                data: completeData,
                                success: true
                            });

                            // Update file status to complete
                            setBatchFiles(prev => prev.map((f, idx) =>
                                idx === i ? { ...f, status: 'complete', result: assessment } : f
                            ));

                        } catch (err) {
                            console.error(`Error processing ${fileInfo.name}:`, err);

                            // Translate error to user-friendly message
                            const errorTranslation = await translateError(err);

                            results.push({
                                fileName: fileInfo.name,
                                error: errorTranslation.friendly,
                                rawError: errorTranslation.raw,
                                success: false
                            });

                            // Update file status to error
                            setBatchFiles(prev => prev.map((f, idx) =>
                                idx === i ? { ...f, status: 'error', error: errorTranslation.friendly, rawError: errorTranslation.raw } : f
                            ));
                        }

                        setProcessingProgress(((i + 1) / batchFiles.length) * 100);
                        setProcessedCount(i + 1);
                    }

                    setBatchResults(results);
                    setCurrentlyProcessing('');
                    setStatusMessage(`âœ“ Completed: ${results.filter(r => r.success).length} successful, ${results.filter(r => !r.success).length} errors`);
                    
                } catch (err) {
                    setError(err.message);
                } finally {
                    setLoading(false);
                }
            };

            const downloadBatchResults = async (format = 'text') => {
                const zip = new JSZip();
                
                if (format === 'text') {
                    // Text format - separate assessment files
                    batchResults.forEach((result, index) => {
                        if (result.success) {
                            const fileName = result.fileName.replace(/\.[^/.]+$/, '') + '_assessment.txt';
                            let content = `LEGAL WRITING ASSESSMENT
========================

Student File: ${result.fileName}
Generated: ${new Date().toISOString()}

`;
                            
                            if (outputControls.includeQuestion && result.data.question) {
                                content += `QUESTION:\n${result.data.question}\n\n`;
                            }
                            if (outputControls.includeStudentAnswer && result.data.studentAnswer) {
                                content += `STUDENT ANSWER:\n${result.data.studentAnswer}\n\n`;
                            }
                            if (outputControls.includeModelAnswer && result.data.modelAnswer) {
                                content += `MODEL ANSWER:\n${result.data.modelAnswer}\n\n`;
                            }
                            if (outputControls.includeRubric && result.data.rubric) {
                                content += `RUBRIC:\n${result.data.rubric}\n\n`;
                            }

                            // Handle challenge workflow format
                            if (result.assessment) {
                                if (typeof result.assessment === 'object' && result.assessment.original) {
                                    // New challenge workflow format
                                    if (outputControls.includeAssessment && result.assessment.original) {
                                        content += `ORIGINAL ASSESSMENT:\n${result.assessment.original}\n\n`;
                                    }
                                    if (outputControls.includeChallenge && result.assessment.challenge) {
                                        content += `STUDENT ADVOCATE'S CHALLENGE:\n${result.assessment.challenge}\n\n`;
                                    }
                                    if (outputControls.includeArbitration && result.assessment.arbitration) {
                                        content += `ARBITRATION REVIEW:\n${result.assessment.arbitration}\n\n`;
                                    }
                                    if (outputControls.includeFinalAssessment && result.assessment.arbitration) {
                                        content += `FINAL ASSESSMENT:\n${result.assessment.arbitration}`;
                                    }
                                } else if (typeof result.assessment === 'string') {
                                    // Legacy string format
                                    if (outputControls.includeAssessment) {
                                        content += `ASSESSMENT:\n${result.assessment}`;
                                    }
                                }
                            }

                            zip.file(fileName, content);
                        } else {
                            const fileName = result.fileName.replace(/\.[^/.]+$/, '') + '_ERROR.txt';
                            zip.file(fileName, `Error processing ${result.fileName}:\n${result.error}`);
                        }
                    });
                } else {
                    // JSON format - complete data structure
                    batchResults.forEach((result, index) => {
                        if (result.success) {
                            const fileName = result.fileName.replace(/\.[^/.]+$/, '') + '_complete.json';
                            const jsonContent = {
                                studentFile: result.fileName,
                                generatedAt: new Date().toISOString()
                            };
                            
                            if (outputControls.includeQuestion && result.data.question) {
                                jsonContent.question = result.data.question;
                            }
                            if (outputControls.includeStudentAnswer && result.data.studentAnswer) {
                                jsonContent.studentAnswer = result.data.studentAnswer;
                            }
                            if (outputControls.includeModelAnswer && result.data.modelAnswer) {
                                jsonContent.modelAnswer = result.data.modelAnswer;
                            }
                            if (outputControls.includeRubric && result.data.rubric) {
                                jsonContent.rubric = result.data.rubric;
                            }

                            // Handle challenge workflow format
                            if (result.assessment) {
                                if (typeof result.assessment === 'object' && result.assessment.original) {
                                    // New challenge workflow format
                                    if (outputControls.includeAssessment && result.assessment.original) {
                                        jsonContent.originalAssessment = result.assessment.original;
                                    }
                                    if (outputControls.includeChallenge && result.assessment.challenge) {
                                        jsonContent.challenge = result.assessment.challenge;
                                    }
                                    if (outputControls.includeArbitration && result.assessment.arbitration) {
                                        jsonContent.arbitrationReview = result.assessment.arbitration;
                                    }
                                    if (outputControls.includeFinalAssessment && result.assessment.arbitration) {
                                        jsonContent.finalAssessment = result.assessment.arbitration;
                                    }
                                } else if (typeof result.assessment === 'string') {
                                    // Legacy string format
                                    if (outputControls.includeAssessment) {
                                        jsonContent.assessment = result.assessment;
                                    }
                                }
                            }

                            zip.file(fileName, JSON.stringify(jsonContent, null, 2));
                        } else {
                            const fileName = result.fileName.replace(/\.[^/.]+$/, '') + '_ERROR.json';
                            const errorContent = {
                                studentFile: result.fileName,
                                success: false,
                                error: result.error,
                                timestamp: new Date().toISOString()
                            };
                            zip.file(fileName, JSON.stringify(errorContent, null, 2));
                        }
                    });
                }

                const blob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const timestamp = new Date().toISOString().split('T')[0];
                a.download = `legal-assessments-${timestamp}-${format}.zip`;
                a.click();
                URL.revokeObjectURL(url);
            };

            const callLLM = async (prompt, cachingConfig = { enabled: false, method: null, cacheableContent: null, nonCacheableContent: null }) => {
                console.log('callLLM called:', { provider, model, promptLength: prompt.length, hasApiKey: !!apiKey, cachingConfig });
                try {
                    if (provider === 'anthropic') {
                        let messages;

                        // Handle caching for Anthropic
                        if (cachingConfig.enabled && cachingConfig.method === 'anthropic' && cachingConfig.cacheableContent) {
                            messages = [
                                {
                                    role: 'user',
                                    content: [
                                        {
                                            type: 'text',
                                            text: cachingConfig.cacheableContent,
                                            cache_control: { type: 'ephemeral' }
                                        },
                                        {
                                            type: 'text',
                                            text: cachingConfig.nonCacheableContent
                                        }
                                    ]
                                }
                            ];
                        } else {
                            messages = [{ role: 'user', content: prompt }];
                        }

                        const response = await fetch('https://api.anthropic.com/v1/messages', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'x-api-key': apiKey,
                                'anthropic-version': '2023-06-01'
                            },
                            body: JSON.stringify({
                                model: model,
                                max_tokens: MAX_COMPLETION_TOKEN_LIMITS.anthropic,
                                messages: messages
                            })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(`Anthropic API Error: ${error.error?.message || response.statusText}`);
                        }

                        const data = await response.json();
                        if (!data.content || !data.content[0]) {
                            throw new Error('Invalid response from Anthropic: no content in response');
                        }
                        return data.content[0].text;
                } else if (provider === 'openai') {
                    // OpenAI: supports explicit caching with cache_control
                    let messages;
                    if (cachingConfig.enabled && cachingConfig.method === 'openai' && cachingConfig.cacheableContent) {
                        messages = [
                            {
                                role: 'user',
                                content: [
                                    {
                                        type: 'text',
                                        text: cachingConfig.cacheableContent,
                                        cache_control: { type: 'ephemeral' }
                                    },
                                    {
                                        type: 'text',
                                        text: cachingConfig.nonCacheableContent
                                    }
                                ]
                            }
                        ];
                    } else {
                        messages = [{ role: 'user', content: prompt }];
                    }

                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: messages,
                            max_tokens: MAX_COMPLETION_TOKEN_LIMITS.openai
                        })
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(`OpenAI API Error: ${error.error?.message || response.statusText}`);
                    }

                    const data = await response.json();
                    if (!data.choices || !data.choices[0]) {
                        throw new Error('Invalid response from OpenAI: no choices in response');
                    }
                    return data.choices[0].message.content;
                } else if (provider === 'google') {
                    // Google: Gemini 2.5 has implicit caching (no code changes needed)
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{ text: prompt }]
                            }],
                            generationConfig: {
                                maxOutputTokens: MAX_COMPLETION_TOKEN_LIMITS.google
                            }
                        })
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(`Google API Error: ${error.error?.message || response.statusText}`);
                    }

                    const data = await response.json();
                    if (!data.candidates || !data.candidates[0]) {
                        throw new Error('Invalid response from Google: no candidates in response');
                    }
                    return data.candidates[0].content.parts[0].text;
                } else if (provider === 'openrouter') {
                    let messages;

                    // Check if underlying model supports caching
                    if (cachingConfig.enabled && cachingConfig.method && cachingConfig.cacheableContent) {
                        if (cachingConfig.method === 'anthropic' || cachingConfig.method === 'openai') {
                            messages = [
                                {
                                    role: 'user',
                                    content: [
                                        {
                                            type: 'text',
                                            text: cachingConfig.cacheableContent,
                                            cache_control: { type: 'ephemeral' }
                                        },
                                        {
                                            type: 'text',
                                            text: cachingConfig.nonCacheableContent
                                        }
                                    ]
                                }
                            ];
                        } else {
                            messages = [{ role: 'user', content: prompt }];
                        }
                    } else {
                        messages = [{ role: 'user', content: prompt }];
                    }

                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`,
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Legal Writing Assessment Tool'
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: messages,
                            max_tokens: model.startsWith('anthropic/')
                                ? MAX_COMPLETION_TOKEN_LIMITS.openrouter.anthropic
                                : model.startsWith('openai/')
                                    ? MAX_COMPLETION_TOKEN_LIMITS.openrouter.openai
                                    : model.includes('gemini-2.5')
                                        ? MAX_COMPLETION_TOKEN_LIMITS.openrouter.google
                                        : MAX_COMPLETION_TOKEN_LIMITS.openrouter.default
                        })
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(`OpenRouter API Error: ${error.error?.message || response.statusText}`);
                    }

                    const data = await response.json();
                    if (!data.choices || !data.choices[0]) {
                        throw new Error('Invalid response from OpenRouter: no choices in response');
                    }
                    return data.choices[0].message.content;
                    }
                } catch (err) {
                    console.error('callLLM ERROR CAUGHT:', {
                        provider: provider,
                        model: model,
                        errorMessage: err.message,
                        errorName: err.name,
                        stack: err.stack,
                        fullError: err
                    });
                    throw err;
                }
            };

            const resetModeState = () => {
                // Called when switching modes - clears mode-specific state but PRESERVES shared context
                setStep(1);
                setInputMode('form');
                setFormData(prev => ({
                    question: prev.question,  // PRESERVE question
                    studentAnswer: '',         // Clear student answer (mode-specific)
                    modelAnswer: prev.modelAnswer,  // PRESERVE model answer
                    rubric: prev.rubric        // PRESERVE rubric
                }));
                setJsonInput('');
                setBatchFiles([]);
                setJsonData(null);
                setAssessment(null);
                setBatchResults([]);
                setError('');
                setStatusMessage('');
                setProcessingProgress(0);
                setProcessedCount(0);
                setTotalCount(0);
            };

            const resetForm = () => {
                // Full reset - clears everything
                setStep(1);
                setInputMode('form');
                setFormData({
                    question: '',
                    studentAnswer: '',
                    modelAnswer: '',
                    rubric: ''
                });
                setJsonInput('');
                setBatchFiles([]);
                setJsonData(null);
                setAssessment(null);
                setBatchResults([]);
                setError('');
                setStatusMessage('');
                setProcessingProgress(0);
                setProcessedCount(0);
                setTotalCount(0);
                setOutputControls({
                    includeQuestion: true,
                    includeStudentAnswer: true,
                    includeModelAnswer: false,
                    includeRubric: false,
                    includeAssessment: false,
                    includeChallenge: false,
                    includeArbitration: false,
                    includeFinalAssessment: true
                });
            };

            const formatFileSize = (bytes) => {
                if (bytes < 1024) return bytes + ' B';
                if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
                return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
            };

            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                if (mins > 0) {
                    return `${mins}m ${secs}s`;
                }
                return `${secs}s`;
            };

            const getFileIcon = (fileName) => {
                const ext = fileName.split('.').pop().toLowerCase();
                switch (ext) {
                    case 'pdf': return 'ðŸ“„';
                    case 'docx': return 'ðŸ“';
                    case 'md': case 'markdown': return 'ðŸ“‹';
                    case 'txt': return 'ðŸ“ƒ';
                    default: return 'ðŸ“';
                }
            };

            return (
                <div className="container">
                    <h1>Legal Writing Assessment Tool</h1>
                    <p className="subtitle">Evaluate legal analysis using IRAC/CREAC framework</p>

                    <div className="mode-toggle">
                        <button
                            className={`mode-button ${mode === 'single' ? 'active' : ''}`}
                            onClick={() => { setMode('single'); resetModeState(); }}
                        >
                            <span style={{fontSize: '18px', marginRight: '8px'}}>ðŸ“</span>
                            <span>Single Assessment</span>
                        </button>
                        <button
                            className={`mode-button ${mode === 'batch' ? 'active' : ''}`}
                            onClick={() => { setMode('batch'); resetModeState(); }}
                        >
                            <span style={{fontSize: '18px', marginRight: '8px'}}>ðŸ“š</span>
                            <span>Batch Processing</span>
                        </button>
                    </div>

                    <div className="section ai-config">
                        <div className="section-title">AI Configuration</div>
                        
                        <label>LLM Provider</label>
                        <div className="provider-select">
                            <div 
                                className={`provider-option ${provider === 'anthropic' ? 'selected' : ''}`}
                                onClick={() => setProvider('anthropic')}
                            >
                                Anthropic
                            </div>
                            <div 
                                className={`provider-option ${provider === 'openai' ? 'selected' : ''}`}
                                onClick={() => setProvider('openai')}
                            >
                                OpenAI
                            </div>
                            <div 
                                className={`provider-option ${provider === 'google' ? 'selected' : ''}`}
                                onClick={() => setProvider('google')}
                            >
                                Google
                            </div>
                            <div 
                                className={`provider-option ${provider === 'openrouter' ? 'selected' : ''}`}
                                onClick={() => setProvider('openrouter')}
                            >
                                OpenRouter
                            </div>
                        </div>

                        <label>API Key <span className="required">*</span></label>
                        <input
                            type="password"
                            value={apiKey}
                            onChange={(e) => handleApiKeyChange(e.target.value)}
                            placeholder={`Enter your ${provider === 'anthropic' ? 'Anthropic' : provider === 'openai' ? 'OpenAI' : provider === 'google' ? 'Google AI' : 'OpenRouter'} API key`}
                        />
                        <button
                            onClick={() => {
                                setApiKey('');
                                localStorage.removeItem(`apiKey_${provider}`);
                                setError('');
                                alert(`API key for ${provider} cleared from browser storage`);
                            }}
                            style={{
                                marginTop: '8px',
                                padding: '8px 12px',
                                background: '#ef5350',
                                color: 'white',
                                border: 'none',
                                borderRadius: '6px',
                                cursor: 'pointer',
                                fontSize: '13px',
                                fontWeight: '500'
                            }}
                            title="Clear saved API key from browser storage"
                        >
                            ðŸ—‘ï¸ Clear Saved Key
                        </button>

                        <label style={{marginTop: '15px'}}>Model</label>
                        <select value={model} onChange={(e) => setModel(e.target.value)}>
                            {provider === 'anthropic' ? (
                                <>
                                    <option value="claude-sonnet-4-5-20250929">Claude Sonnet 4.5</option>
                                    <option value="claude-haiku-4-5">Claude Haiku 4.5</option>
                                </>
                            ) : provider === 'openai' ? (
                                <>
                                    <option value="gpt-5">GPT-5</option>
                                    <option value="gpt-5-mini">GPT-5 Mini</option>
                                    <option value="gpt-5-nano">GPT-5 Nano</option>
                                </>
                            ) : provider === 'google' ? (
                                <>
                                    <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                                    <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                                    <option value="gemini-2.5-flash-lite">Gemini 2.5 Flash Lite</option>
                                </>
                            ) : (
                                <>
                                    <option value="anthropic/claude-sonnet-4.5">Claude Sonnet 4.5</option>
                                    <option value="anthropic/claude-haiku-4.5">Claude Haiku 4.5</option>
                                    <option value="openai/gpt-5">GPT-5</option>
                                    <option value="openai/gpt-5-mini">GPT-5 Mini</option>
                                    <option value="openai/gpt-5-nano">GPT-5 Nano</option>
                                    <option value="google/gemini-2.5-pro">Gemini 2.5 Pro</option>
                                    <option value="google/gemini-2.5-flash">Gemini 2.5 Flash</option>
                                    <option value="google/gemini-2.5-flash-lite">Gemini 2.5 Flash Lite</option>
                                    <option value="z-ai/glm-4.5:free">GLM-4.5 (Free)</option>
                                </>
                            )}
                        </select>

                        <div className="info-box">
                            Supports: .txt, .md, .pdf, .docx files
                        </div>

                        {supportsCaching(provider, model, true).supported && (
                            <>
                                <label style={{marginTop: '15px', display: 'flex', alignItems: 'center', gap: '10px', cursor: 'pointer'}}>
                                    <input
                                        type="checkbox"
                                        checked={cachingEnabled}
                                        onChange={(e) => setCachingEnabled(e.target.checked)}
                                        style={{width: '18px', height: '18px', cursor: 'pointer'}}
                                    />
                                    <span>Enable Prompt Caching</span>
                                </label>
                                <div style={{marginTop: '10px', padding: '10px', background: '#e6fffa', border: '1px solid #81e6d9', borderRadius: '6px', fontSize: '13px', color: '#234e52'}}>
                                    {supportsCaching(provider, model, true).method === 'implicit' ? (
                                        <>âœ“ Prompt caching enabled (implicit - automatic)</>
                                    ) : cachingEnabled ? (
                                        <>âœ“ Prompt caching enabled ({supportsCaching(provider, model, true).method})</>
                                    ) : (
                                        <>âŠ˜ Prompt caching disabled by user</>
                                    )}
                                </div>
                            </>
                        )}

                        {!supportsCaching(provider, model, true).supported && (
                            <div style={{marginTop: '10px', padding: '10px', background: '#f0f0f0', border: '1px solid #ccc', borderRadius: '6px', fontSize: '13px', color: '#555'}}>
                                âŠ˜ Prompt caching not available for this model
                            </div>
                        )}

                        {/* Advanced Diagnostics Section */}
                        <div style={{marginTop: '25px', paddingTop: '20px', borderTop: '1px solid #e2e8f0'}}>
                            <div style={{display: 'flex', alignItems: 'center', gap: '10px', cursor: 'pointer', marginBottom: '15px'}} onClick={() => setUseCustomErrorModel(!useCustomErrorModel)}>
                                <span style={{fontSize: '16px', color: '#667eea', fontWeight: '500'}}>âš™ï¸ Advanced Diagnostics</span>
                                <span style={{fontSize: '12px', color: '#a0aec0', fontStyle: 'italic'}}>(optional)</span>
                            </div>

                            {useCustomErrorModel && (
                                <div style={{padding: '15px', background: '#f7fafc', border: '1px solid #cbd5e0', borderRadius: '6px', marginBottom: '15px'}}>
                                    <p style={{fontSize: '13px', color: '#4a5568', marginBottom: '10px'}}>
                                        If error messages are unclear, you can use a different model to help explain them.
                                    </p>
                                    <label style={{display: 'block', marginBottom: '8px', fontSize: '13px', fontWeight: '500', color: '#2d3748'}}>
                                        Error Diagnosis Model
                                    </label>
                                    <select
                                        value={errorDiagnosisModel || ''}
                                        onChange={(e) => setErrorDiagnosisModel(e.target.value)}
                                        style={{width: '100%', padding: '8px', borderRadius: '4px', border: '1px solid #cbd5e0', fontSize: '13px'}}
                                    >
                                        <option value="">Use selected assessment model (default)</option>
                                        {provider === 'anthropic' ? (
                                            <>
                                                <option value="claude-sonnet-4-5-20250929">Claude Sonnet 4.5</option>
                                                <option value="claude-haiku-4-5">Claude Haiku 4.5</option>
                                            </>
                                        ) : provider === 'openai' ? (
                                            <>
                                                <option value="gpt-5">GPT-5</option>
                                                <option value="gpt-5-mini">GPT-5 Mini</option>
                                                <option value="gpt-5-nano">GPT-5 Nano</option>
                                            </>
                                        ) : provider === 'google' ? (
                                            <>
                                                <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                                                <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                                                <option value="gemini-2.5-flash-lite">Gemini 2.5 Flash Lite</option>
                                            </>
                                        ) : (
                                            <>
                                                <option value="anthropic/claude-sonnet-4.5">Claude Sonnet 4.5</option>
                                                <option value="anthropic/claude-haiku-4.5">Claude Haiku 4.5</option>
                                                <option value="openai/gpt-5">GPT-5</option>
                                                <option value="openai/gpt-5-mini">GPT-5 Mini</option>
                                                <option value="openai/gpt-5-nano">GPT-5 Nano</option>
                                                <option value="google/gemini-2.5-pro">Gemini 2.5 Pro</option>
                                                <option value="google/gemini-2.5-flash">Gemini 2.5 Flash</option>
                                                <option value="google/gemini-2.5-flash-lite">Gemini 2.5 Flash Lite</option>
                                                <option value="z-ai/glm-4.5:free">GLM-4.5 (Free)</option>
                                            </>
                                        )}
                                    </select>
                                    <p style={{fontSize: '12px', color: '#718096', marginTop: '8px'}}>
                                        This model will be used to explain error messages if they don't match common patterns.
                                    </p>
                                </div>
                            )}

                            <label style={{display: 'flex', alignItems: 'center', gap: '10px', cursor: 'pointer'}}>
                                <input
                                    type="checkbox"
                                    checked={useCustomErrorModel}
                                    onChange={(e) => setUseCustomErrorModel(e.target.checked)}
                                    style={{width: '18px', height: '18px', cursor: 'pointer'}}
                                />
                                <span style={{fontSize: '13px', color: '#4a5568'}}>Use custom model for error diagnosis</span>
                            </label>
                        </div>
                    </div>

                    {mode === 'single' ? (
                        // Single mode UI
                        <>
                            {step === 1 && (
                                <>
                                    <div className="input-mode-toggle">
                                        <button
                                            className={`input-mode-button ${inputMode === 'form' ? 'active' : ''}`}
                                            onClick={() => setInputMode('form')}
                                        >
                                            ðŸ“ Form Input
                                        </button>
                                        <button
                                            className={`input-mode-button ${inputMode === 'json' ? 'active' : ''}`}
                                            onClick={() => setInputMode('json')}
                                        >
                                            ðŸ“„ JSON Input
                                        </button>
                                    </div>

                                    {inputMode === 'json' ? (
                                        <div className="section">
                                            <div className="section-title">
                                                JSON Assessment Data <span className="required">*</span>
                                            </div>
                                            <p style={{fontSize: '13px', color: '#718096', marginBottom: '10px'}}>
                                                Paste JSON with fields: question, studentAnswer, modelAnswer, rubric
                                            </p>
                                            <textarea
                                                className="json-input-area"
                                                value={jsonInput}
                                                onChange={(e) => setJsonInput(e.target.value)}
                                                placeholder={`{\n  "question": "...",\n  "studentAnswer": "...",\n  "modelAnswer": "...",\n  "rubric": "..."\n}`}
                                            />
                                            <input
                                                ref={jsonFileInputRef}
                                                type="file"
                                                accept=".json"
                                                onChange={(e) => e.target.files[0] && handleJsonFileUpload(e.target.files[0])}
                                                style={{marginTop: '10px'}}
                                            />
                                            <p style={{fontSize: '12px', color: '#718096', marginTop: '5px'}}>
                                                Or upload a .json file
                                            </p>
                                        </div>
                                    ) : (
                                        <>
                                            <div className="section">
                                                <div className="section-title">Question (Optional)</div>
                                                <textarea
                                                    value={formData.question}
                                                    onChange={(e) => handleInputChange('question', e.target.value)}
                                                    placeholder="Enter or upload the exam question..."
                                                />
                                                <input
                                                    type="file"
                                                    accept=".txt,.md,.pdf,.docx"
                                                    onChange={(e) => e.target.files[0] && handleFileUpload('question', e.target.files[0])}
                                                    style={{marginTop: '10px'}}
                                                />
                                            </div>

                                            <div className="section">
                                                <div className="section-title">
                                                    Student Answer <span className="required">*</span>
                                                </div>
                                                <textarea
                                                    value={formData.studentAnswer}
                                                    onChange={(e) => handleInputChange('studentAnswer', e.target.value)}
                                                    placeholder="Paste or upload student answer..."
                                                    style={{minHeight: '200px'}}
                                                />
                                                <input
                                                    type="file"
                                                    accept=".txt,.md,.pdf,.docx"
                                                    onChange={(e) => e.target.files[0] && handleFileUpload('studentAnswer', e.target.files[0])}
                                                    style={{marginTop: '10px'}}
                                                />
                                            </div>

                                            <div className="section">
                                                <div className="section-title">Model Answer (Optional)</div>
                                                <textarea
                                                    value={formData.modelAnswer}
                                                    onChange={(e) => handleInputChange('modelAnswer', e.target.value)}
                                                    placeholder="Enter or upload model answer..."
                                                />
                                                <input
                                                    type="file"
                                                    accept=".txt,.md,.pdf,.docx"
                                                    onChange={(e) => e.target.files[0] && handleFileUpload('modelAnswer', e.target.files[0])}
                                                    style={{marginTop: '10px'}}
                                                />
                                            </div>

                                            <div className="section">
                                                <div className="section-title">Rubric (Optional)</div>
                                                <textarea
                                                    value={formData.rubric}
                                                    onChange={(e) => handleInputChange('rubric', e.target.value)}
                                                    placeholder="Enter or upload grading rubric..."
                                                />
                                                <input
                                                    type="file"
                                                    accept=".txt,.md,.pdf,.docx"
                                                    onChange={(e) => e.target.files[0] && handleFileUpload('rubric', e.target.files[0])}
                                                    style={{marginTop: '10px'}}
                                                />
                                            </div>
                                        </>
                                    )}

                                    {statusMessage && (
                                        <div className="status-message">
                                            {statusMessage}
                                            {loading && <span className="timer-display">â± {formatTime(elapsedTime)}</span>}
                                        </div>
                                    )}

                                    <div className="section">
                                        <div className="section-title">Output Controls</div>
                                        <p style={{fontSize: '14px', color: '#666', marginBottom: '15px'}}>
                                            Choose what content to include in downloaded files:
                                        </p>
                                        <div className="output-controls-container">
                                            <div className="output-controls-grid">
                                                <label className="output-control-label">
                                                    <input
                                                        type="checkbox"
                                                        checked={outputControls.includeQuestion}
                                                        onChange={(e) => handleOutputControlChange('includeQuestion', e.target.checked)}
                                                    />
                                                    <span>Question</span>
                                                </label>
                                                <label className="output-control-label">
                                                    <input
                                                        type="checkbox"
                                                        checked={outputControls.includeStudentAnswer}
                                                        onChange={(e) => handleOutputControlChange('includeStudentAnswer', e.target.checked)}
                                                    />
                                                    <span>Student Answer</span>
                                                </label>
                                                <label className="output-control-label">
                                                    <input
                                                        type="checkbox"
                                                        checked={outputControls.includeModelAnswer}
                                                        onChange={(e) => handleOutputControlChange('includeModelAnswer', e.target.checked)}
                                                    />
                                                    <span>Model Answer</span>
                                                </label>
                                                <label className="output-control-label">
                                                    <input
                                                        type="checkbox"
                                                        checked={outputControls.includeRubric}
                                                        onChange={(e) => handleOutputControlChange('includeRubric', e.target.checked)}
                                                    />
                                                    <span>Rubric</span>
                                                </label>
                                                <label className="output-control-label">
                                                    <input
                                                        type="checkbox"
                                                        checked={outputControls.includeAssessment}
                                                        onChange={(e) => handleOutputControlChange('includeAssessment', e.target.checked)}
                                                    />
                                                    <span>Original Assessment</span>
                                                </label>
                                                <label className="output-control-label">
                                                    <input
                                                        type="checkbox"
                                                        checked={outputControls.includeChallenge}
                                                        onChange={(e) => handleOutputControlChange('includeChallenge', e.target.checked)}
                                                    />
                                                    <span>Challenge</span>
                                                </label>
                                                <label className="output-control-label">
                                                    <input
                                                        type="checkbox"
                                                        checked={outputControls.includeArbitration}
                                                        onChange={(e) => handleOutputControlChange('includeArbitration', e.target.checked)}
                                                    />
                                                    <span>Arbitration Review</span>
                                                </label>
                                                <label className="output-control-label">
                                                    <input
                                                        type="checkbox"
                                                        checked={outputControls.includeFinalAssessment}
                                                        onChange={(e) => handleOutputControlChange('includeFinalAssessment', e.target.checked)}
                                                    />
                                                    <span>Final Assessment</span>
                                                </label>
                                            </div>
                                        </div>
                                    </div>

                                    <button
                                        onClick={processSingleMode}
                                        disabled={(inputMode === 'form' && !formData.studentAnswer) || (inputMode === 'json' && !jsonInput) || !apiKey || loading}
                                    >
                                        {loading ? <span className="loading"></span> : 'Generate Assessment Data'}
                                    </button>
                                </>
                            )}

                            {step === 2 && jsonData && (
                                <>
                                    <div style={{padding: '20px', background: '#f0fff4', borderRadius: '8px', marginBottom: '20px'}}>
                                        <h3 style={{color: '#22543d', marginBottom: '10px'}}>âœ“ Assessment Data Ready</h3>
                                        <p style={{marginBottom: '15px'}}>JSON structure created successfully</p>
                                        <div className="download-buttons">
                                            <button 
                                                onClick={() => downloadJSON(jsonData, 'assessment-data.json')}
                                                className="secondary-button icon-button"
                                            >
                                                ðŸ“¥ Download JSON
                                            </button>
                                        </div>
                                    </div>

                                    {statusMessage && (
                                        <div className="status-message">
                                            {statusMessage}
                                            {loading && <span className="timer-display">â± {formatTime(elapsedTime)}</span>}
                                        </div>
                                    )}

                                    <button onClick={performSingleAssessmentStep} disabled={loading}>
                                        {loading ? <span className="loading"></span> : 'Perform Assessment'}
                                    </button>
                                    <button onClick={resetForm} className="secondary-button" style={{marginTop: '10px'}}>
                                        Start Over
                                    </button>
                                </>
                            )}

                            {step === 3 && assessment && (
                                <>
                                    <div style={{padding: '30px', background: '#f7fafc', borderRadius: '12px', marginBottom: '20px'}}>
                                        <h2 style={{marginBottom: '20px'}}>ðŸ“Š Original Assessment</h2>
                                        <div style={{whiteSpace: 'pre-wrap', lineHeight: '1.8', padding: '20px', background: 'white', borderRadius: '8px', border: '2px solid #e2e8f0'}}>
                                            {assessment.original}
                                        </div>
                                    </div>

                                    <div style={{padding: '30px', background: '#fffaf0', borderRadius: '12px', marginBottom: '20px'}}>
                                        <h2 style={{marginBottom: '20px'}}>ðŸŽ¯ Student Advocate's Challenge</h2>
                                        <div style={{whiteSpace: 'pre-wrap', lineHeight: '1.8', padding: '20px', background: 'white', borderRadius: '8px', border: '2px solid #fbd38d'}}>
                                            {assessment.challenge}
                                        </div>
                                    </div>

                                    <div style={{padding: '30px', background: '#f0fff4', borderRadius: '12px', marginBottom: '20px'}}>
                                        <h2 style={{marginBottom: '20px'}}>âš–ï¸ Arbitrator's Decision & Revised Assessment</h2>
                                        <div style={{whiteSpace: 'pre-wrap', lineHeight: '1.8', padding: '20px', background: 'white', borderRadius: '8px', border: '2px solid #9ae6b4'}}>
                                            {assessment.arbitration}
                                        </div>
                                    </div>

                                    <div className="download-buttons">
                                        <button
                                            onClick={() => downloadText(assessment, 'assessment-complete.txt')}
                                            className="secondary-button icon-button"
                                        >
                                            ðŸ“¥ Download Assessment (TXT)
                                        </button>
                                        <button
                                            onClick={() => downloadJSON({
                                                ...jsonData,
                                                originalAssessment: assessment.original,
                                                challenge: assessment.challenge,
                                                arbitration: assessment.arbitration
                                            }, 'complete-assessment-with-challenge.json')}
                                            className="secondary-button icon-button"
                                        >
                                            ðŸ“¥ Download Complete (JSON)
                                        </button>
                                    </div>

                                    <button onClick={resetForm} style={{marginTop: '15px'}}>
                                        Assess Another Answer
                                    </button>
                                </>
                            )}
                        </>
                    ) : (
                        // Batch mode UI
                        <>
                            <div className="section">
                                <div className="section-title">Context Files (Optional)</div>
                                
                                <label>Question</label>
                                <textarea
                                    value={formData.question}
                                    onChange={(e) => handleInputChange('question', e.target.value)}
                                    placeholder="Enter or upload question (will be used for all assessments)..."
                                    rows="3"
                                />
                                <input
                                    type="file"
                                    accept=".txt,.md,.pdf,.docx"
                                    onChange={(e) => e.target.files[0] && handleFileUpload('question', e.target.files[0])}
                                    style={{marginTop: '10px', marginBottom: '15px'}}
                                />

                                <label>Model Answer</label>
                                <textarea
                                    value={formData.modelAnswer}
                                    onChange={(e) => handleInputChange('modelAnswer', e.target.value)}
                                    placeholder="Enter or upload model answer (will be used for all assessments)..."
                                    rows="3"
                                />
                                <input
                                    type="file"
                                    accept=".txt,.md,.pdf,.docx"
                                    onChange={(e) => e.target.files[0] && handleFileUpload('modelAnswer', e.target.files[0])}
                                    style={{marginTop: '10px', marginBottom: '15px'}}
                                />

                                <label>Rubric</label>
                                <textarea
                                    value={formData.rubric}
                                    onChange={(e) => handleInputChange('rubric', e.target.value)}
                                    placeholder="Enter or upload rubric (will be used for all assessments)..."
                                    rows="3"
                                />
                                <input
                                    type="file"
                                    accept=".txt,.md,.pdf,.docx"
                                    onChange={(e) => e.target.files[0] && handleFileUpload('rubric', e.target.files[0])}
                                    style={{marginTop: '10px'}}
                                />
                            </div>

                            <div className="section">
                                <div className="section-title">
                                    Student Answer Files <span className="required">*</span>
                                </div>
                                
                                <div 
                                    className={`file-upload-zone ${batchFiles.length > 0 ? 'has-files' : ''}`}
                                    onClick={() => fileInputRef.current?.click()}
                                    onDrop={handleDrop}
                                    onDragOver={handleDragOver}
                                >
                                    <div className="upload-icon">ðŸ“¤</div>
                                    <p style={{fontSize: '16px', fontWeight: '500', marginBottom: '8px'}}>
                                        Drop student answer files here or click to browse
                                    </p>
                                    <p style={{fontSize: '14px', color: '#718096'}}>
                                        Supports: .txt, .md, .pdf, .docx
                                    </p>
                                    <input
                                        ref={fileInputRef}
                                        type="file"
                                        multiple
                                        accept=".txt,.md,.pdf,.docx"
                                        onChange={(e) => handleBatchFilesSelect(e.target.files)}
                                        style={{display: 'none'}}
                                    />
                                </div>

                                {batchFiles.length > 0 && (
                                    <div className="file-list">
                                        {batchFiles.map((file, index) => (
                                            <div key={index} className="file-item">
                                                <div className="file-item-info">
                                                    <span className="file-icon">{getFileIcon(file.name)}</span>
                                                    <div>
                                                        <div className="file-name">{file.name}</div>
                                                        <div className="file-size">{formatFileSize(file.size)}</div>
                                                    </div>
                                                </div>
                                                <div style={{display: 'flex', gap: '10px', alignItems: 'center'}}>
                                                    <span className={`file-status ${file.status}`}>
                                                        {file.status === 'pending' && 'â³ Pending'}
                                                        {file.status === 'processing' && 'âš™ï¸ Processing'}
                                                        {file.status === 'complete' && 'âœ… Complete'}
                                                        {file.status === 'error' && 'âŒ Error'}
                                                    </span>
                                                    {file.status === 'pending' && (
                                                        <button 
                                                            className="remove-file"
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                removeFile(index);
                                                            }}
                                                        >
                                                            Remove
                                                        </button>
                                                    )}
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>

                            {loading && (
                                <div className="progress-container">
                                    <div className="progress-bar">
                                        <div className="progress-fill" style={{width: `${processingProgress}%`}}>
                                            {Math.round(processingProgress)}%
                                        </div>
                                    </div>
                                    <div className="progress-text">
                                        <strong>{processedCount} of {totalCount} completed</strong>
                                        <br/>
                                        Currently processing: {currentlyProcessing}
                                        <br/>
                                        <span className="timer-display">â± Elapsed: {formatTime(elapsedTime)}</span>
                                    </div>
                                    {statusMessage && (
                                        <div className="status-message" style={{marginTop: '15px'}}>
                                            {statusMessage}
                                        </div>
                                    )}
                                </div>
                            )}

                            {batchResults.length > 0 && (
                                <div className="results-summary">
                                    {batchResults.filter(r => !r.success).length === 0 ? (
                                        <>
                                            <h3>âœ… Batch Processing Complete</h3>
                                            <p style={{marginTop: '10px', color: '#22543d'}}>
                                                Successfully processed {batchResults.length} files
                                            </p>
                                        </>
                                    ) : (
                                        <>
                                            <h3 style={{color: '#c53030'}}>âš ï¸ Batch Processing Failed</h3>
                                            <p style={{marginTop: '10px', color: '#742a2a'}}>
                                                Processed {batchResults.length} files:
                                                {' '}<strong>{batchResults.filter(r => r.success).length} successful</strong>,
                                                {' '}<strong style={{color: '#c53030'}}>{batchResults.filter(r => !r.success).length} errors</strong>
                                            </p>
                                        </>
                                    )}
                                </div>
                            )}

                            {/* Error Details Table */}
                            {batchResults.filter(r => !r.success).length > 0 && (
                                <div style={{marginTop: '25px', padding: '15px', background: '#fff5f5', border: '1px solid #feb2b2', borderRadius: '8px'}}>
                                    <h4 style={{color: '#c53030', marginBottom: '15px'}}>Error Details</h4>
                                    {batchResults.map((result, idx) => (
                                        !result.success && (
                                            <div key={idx} style={{marginBottom: '15px', padding: '12px', background: 'white', border: '1px solid #fed7d7', borderRadius: '6px'}}>
                                                <div style={{display: 'flex', alignItems: 'flex-start', justifyContent: 'space-between', gap: '10px'}}>
                                                    <div style={{flex: 1}}>
                                                        <div style={{fontSize: '14px', fontWeight: '500', color: '#c53030', marginBottom: '8px'}}>
                                                            âŒ {result.fileName}
                                                        </div>
                                                        <div style={{fontSize: '14px', color: '#2d3748', lineHeight: '1.5', marginBottom: '8px'}}>
                                                            {result.error}
                                                        </div>
                                                        {result.rawError && (
                                                            <details style={{fontSize: '12px', color: '#718096', marginTop: '10px'}}>
                                                                <summary style={{cursor: 'pointer', color: '#4299e1', fontWeight: '500', marginBottom: '8px'}}>
                                                                    Show technical details
                                                                </summary>
                                                                <div style={{padding: '8px 12px', background: '#edf2f7', borderRadius: '4px', borderLeft: '3px solid #4299e1', marginTop: '8px', fontFamily: 'monospace', fontSize: '11px', wordBreak: 'break-word'}}>
                                                                    {result.rawError}
                                                                </div>
                                                            </details>
                                                        )}
                                                    </div>
                                                    <button
                                                        onClick={() => {
                                                            const text = `Error in ${result.fileName}:\n\n${result.error}\n\nTechnical details:\n${result.rawError || 'N/A'}`;
                                                            navigator.clipboard.writeText(text).then(() => {
                                                                alert('Error details copied to clipboard');
                                                            });
                                                        }}
                                                        style={{padding: '6px 10px', fontSize: '12px', background: '#4299e1', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer', whiteSpace: 'nowrap', marginTop: '5px'}}
                                                    >
                                                        ðŸ“‹ Copy
                                                    </button>
                                                </div>
                                            </div>
                                        )
                                    ))}
                                </div>
                            )}

                            <div className="section">
                                <div className="section-title">Output Controls</div>
                                <p style={{fontSize: '14px', color: '#666', marginBottom: '15px'}}>
                                    Choose what content to include in downloaded files:
                                </p>
                                <div className="output-controls-container">
                                    <div className="output-controls-grid">
                                        <label className="output-control-label">
                                            <input
                                                type="checkbox"
                                                checked={outputControls.includeQuestion}
                                                onChange={(e) => handleOutputControlChange('includeQuestion', e.target.checked)}
                                            />
                                            <span>Question</span>
                                        </label>
                                        <label className="output-control-label">
                                            <input
                                                type="checkbox"
                                                checked={outputControls.includeStudentAnswer}
                                                onChange={(e) => handleOutputControlChange('includeStudentAnswer', e.target.checked)}
                                            />
                                            <span>Student Answer</span>
                                        </label>
                                        <label className="output-control-label">
                                            <input
                                                type="checkbox"
                                                checked={outputControls.includeModelAnswer}
                                                onChange={(e) => handleOutputControlChange('includeModelAnswer', e.target.checked)}
                                            />
                                            <span>Model Answer</span>
                                        </label>
                                        <label className="output-control-label">
                                            <input
                                                type="checkbox"
                                                checked={outputControls.includeRubric}
                                                onChange={(e) => handleOutputControlChange('includeRubric', e.target.checked)}
                                            />
                                            <span>Rubric</span>
                                        </label>
                                        <label className="output-control-label">
                                            <input
                                                type="checkbox"
                                                checked={outputControls.includeAssessment}
                                                onChange={(e) => handleOutputControlChange('includeAssessment', e.target.checked)}
                                            />
                                            <span>Original Assessment</span>
                                        </label>
                                        <label className="output-control-label">
                                            <input
                                                type="checkbox"
                                                checked={outputControls.includeChallenge}
                                                onChange={(e) => handleOutputControlChange('includeChallenge', e.target.checked)}
                                            />
                                            <span>Challenge</span>
                                        </label>
                                        <label className="output-control-label">
                                            <input
                                                type="checkbox"
                                                checked={outputControls.includeArbitration}
                                                onChange={(e) => handleOutputControlChange('includeArbitration', e.target.checked)}
                                            />
                                            <span>Arbitration Review</span>
                                        </label>
                                        <label className="output-control-label">
                                            <input
                                                type="checkbox"
                                                checked={outputControls.includeFinalAssessment}
                                                onChange={(e) => handleOutputControlChange('includeFinalAssessment', e.target.checked)}
                                            />
                                            <span>Final Assessment</span>
                                        </label>
                                    </div>
                                </div>
                            </div>

                            <div className="batch-controls">
                                {!loading && batchResults.length === 0 && (
                                    <button
                                        onClick={processBatchMode}
                                        disabled={batchFiles.length === 0 || !apiKey}
                                    >
                                        Process All Files ({batchFiles.length})
                                    </button>
                                )}

                                {batchResults.length > 0 && (
                                    <>
                                        {batchResults.filter(r => !r.success).length > 0 && (
                                            <button
                                                onClick={() => {
                                                    setBatchResults([]);
                                                    setProcessingProgress(0);
                                                    setProcessedCount(0);
                                                }}
                                                style={{background: '#ed8936', marginRight: '10px'}}
                                            >
                                                ðŸ”„ Retry Processing
                                            </button>
                                        )}
                                        {batchResults.filter(r => r.success).length > 0 && (
                                            <>
                                                <button onClick={() => downloadBatchResults('text')} className="icon-button">
                                                    ðŸ“¥ Download Text Files (ZIP)
                                                </button>
                                                <button onClick={() => downloadBatchResults('json')} className="icon-button">
                                                    ðŸ“¥ Download JSON Files (ZIP)
                                                </button>
                                            </>
                                        )}
                                        <button onClick={resetForm} className="secondary-button">
                                            {batchResults.filter(r => !r.success).length > 0 ? 'Start Over' : 'Start New Batch'}
                                        </button>
                                    </>
                                )}
                            </div>
                        </>
                    )}

                    {error && <div className="error">{error}</div>}
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
